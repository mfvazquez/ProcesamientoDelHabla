
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Pr&aacute;ctica 4: Linear Predictive Coding(LPC)</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-04-08"><meta name="DC.source" content="Practica4.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Pr&aacute;ctica 4: Linear Predictive Coding(LPC)</h1><!--introduction--><p>V&aacute;zquez Mat&iacute;as - Padron:91523 - <tt>mfvazquezfiuba@gmail.com</tt></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">LPC y la envolvente del espectro: chequeo</a></li><li><a href="#2">Constantes utilizadas</a></li><li><a href="#3">Comparaci&oacute;n de la se&ntilde;al temporal y la predicha</a></li><li><a href="#4">Envolvente de la se&ntilde;al temporal y la predicha</a></li><li><a href="#5">LPC y la envolvente del espectro: An&aacute;lisis en todo el audio</a></li><li><a href="#6">Constantes utilizadas</a></li><li><a href="#7">Calculo anterior sobre toda la se&ntilde;al</a></li><li><a href="#8">Envolventes de las vocales</a></li><li><a href="#9">Comparaci&oacute;n de la superficie obtenida con el espectrograma</a></li><li><a href="#10">LPC aplicado a codificaci&oacute;n</a></li><li><a href="#11">Obtenci&oacute;n del error y sintetizado de la se&ntilde;al</a></li><li><a href="#12">Errores redondeados</a></li><li><a href="#13">Grafico de los errores y las se&ntilde;ales sintetizadas</a></li><li><a href="#14">Errores</a></li><li><a href="#15">Se&ntilde;ales sintetizadas</a></li></ul></div><h2 id="1">LPC y la envolvente del espectro: chequeo</h2><p>Se realizar&aacute; un chequeo aplicando LPC a una secci&oacute;n espec&iacute;fica de ancho temporal fijo sobre una se&ntilde;al, para observar la envolvente del espectro.</p><h2 id="2">Constantes utilizadas</h2><div><ul><li><tt>ventana</tt>: el ancho de la ventana utiliaza, en mseg.</li><li><tt>ancho</tt>: es la cantidad de elementos del audio que componen 25 mseg de audio.</li><li><tt>inicio</tt>: subindice a partir del cual se aplica la ventana.</li><li><tt>M</tt>: numero de coeficientes utilizados</li><li><tt>t</tt>: eje X de los gr&aacute;ficos en funci&oacute;n del tiempo.</li><li><tt>f</tt>: eje X de los gr&aacute;ficos en funci&oacute;n de la frecuencia.</li></ul></div><pre class="codeinput">close <span class="string">all</span>
clear

[audio, Fs] = audioread(<span class="string">'fantasia.wav'</span>);

ventana = 25e-3;
ancho =  ventana  * Fs;

inicio = 14000;
M = 20;
S = audio(inicio:inicio+ancho-1);

t = 0:1/Fs:ventana-1/Fs;
t = t*1e3; <span class="comment">% Paso el tiempo a mseg.</span>
f = 0:Fs/ancho:Fs - Fs/ancho;
</pre><h2 id="3">Comparaci&oacute;n de la se&ntilde;al temporal y la predicha</h2><p>Mediante la autocorrelaci&oacute;n del fragmento de audio, se obtienen los coeficientes rho, y luego con estos se obtienen los coeficientes LPC. Con estos coeficientes se obtiene la se&ntilde;al de audio predicha utilizando la funci&oacute;n <tt>filter</tt>. Luego restando la se&ntilde;al temporal y la predicha se obtiene el error. Se observa que tiene picos espaciados aproximadamente en 5 mseg. Y que tiene una amplitud m&aacute;xima de alrededor 0.07, exceptuando los primeros subindices del error ya que la se&ntilde;al temporal es un audio empezado, y la predicha se obtiene utilizando condiciones iniciales nulas.</p><pre class="codeinput">autocorrelacion = xcorr(S);
rho = autocorrelacion(ancho:ancho+M-1);   <span class="comment">% rho = [rho(0) rho(1) ... rho(M)]</span>

subindices = toeplitz(1:M-1);
R = rho(subindices);

B= R\rho(2:M);  <span class="comment">% inv(R) * rho(2:M)</span>

S_estimado = filter([0; B],1 ,S); <span class="comment">% Filter es un filtro causal</span>

figure
plot(t, S,<span class="string">'b'</span>)
hold <span class="string">on</span>
plot(t, S_estimado,<span class="string">'r'</span>);
xlabel(<span class="string">'tiempo [ms]'</span>)
ylabel(<span class="string">'Amplitud'</span>)
legend(<span class="string">'se&ntilde;al original'</span>,<span class="string">'se&ntilde;al predicha'</span>)

error = S_estimado-S;
figure
plot(t,error);
legend(<span class="string">'error'</span>)
xlabel(<span class="string">'tiempo [ms]'</span>)
ylabel(<span class="string">'Amplitud'</span>)
</pre><img vspace="5" hspace="5" src="Practica4_01.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="Practica4_02.png" style="width:560px;height:420px;" alt=""> <h2 id="4">Envolvente de la se&ntilde;al temporal y la predicha</h2><p>Se muestra un gr&aacute;fico de la envolvente del espectro del audio ventaneado. Para la se&ntilde;al temporal se usa la funci&oacute;n <tt>fft</tt> mientras que para la predicha se usa la funci&oacute;n <tt>freqz</tt> que devuelve la respuesta en frecuencia del filtro. Se verifica que el primer pico se encuentra en los 720Hz, por lo que esta secci&oacute;n de audio se tratar&iacute;a de la vocal <tt>a</tt>.</p><pre class="codeinput">G = sqrt( rho(1) -  B' * rho(2:end));

fft_S = abs(fft(S));
fft_S_estimado = abs(freqz(G,[1;-B], ancho, <span class="string">'whole'</span>));

figure
plot(f(1:ancho/2),fft_S(1:ancho/2),<span class="string">'b'</span>)
hold <span class="string">on</span>
plot(f(1:ancho/2),fft_S_estimado(1:ancho/2),<span class="string">'r'</span>);
legend(<span class="string">'FFT(S)'</span>, <span class="string">'FFT(S estimada)'</span>)
xlabel(<span class="string">'Frecuencia [Hz]'</span>)
ylabel(<span class="string">'Amplitud'</span>)
</pre><img vspace="5" hspace="5" src="Practica4_03.png" style="width:560px;height:420px;" alt=""> <h2 id="5">LPC y la envolvente del espectro: An&aacute;lisis en todo el audio</h2><p>Se realizar&aacute; el mismo an&aacute;lisis que en el intervalo de 25mseg anterior pero a todo el audio. Se recorrer&aacute; el audio cada 10mseg aplicando ventanas de 25mseg para obtener la envolvente del espectro en cada secci&oacute;n, de forma de obtener una superficie que ser&aacute; semejante a un espectrograma.</p><h2 id="6">Constantes utilizadas</h2><div><ul><li><tt>paso</tt>: intervalo en tiempo que hay entre cada secci&oacute;n de audio tomada.</li><li><tt>inicios</tt>: vector con la posici&oacute;n del audio donde se inicia el analisis.</li></ul></div><pre class="codeinput">clearvars <span class="string">-except</span> <span class="string">audio</span> <span class="string">Fs</span> <span class="string">M</span> <span class="string">ventana</span> <span class="string">ancho</span>

paso = 10e-3;
inicios = 1:paso*Fs:length(audio)-ancho;
</pre><h2 id="7">Calculo anterior sobre toda la se&ntilde;al</h2><pre class="codeinput"><span class="keyword">for</span> x = 1:length(inicios)

    S = audio(inicios(x):inicios(x)+ancho-1);

    <span class="comment">% S_estimado</span>
    autocorrelacion = xcorr(S);
    rho = autocorrelacion(ancho:ancho+M-1);   <span class="comment">% rho = [rho(0) rho(1) ... rho(M)]</span>

    subindices = toeplitz(1:M-1);
    R = rho(subindices);
    B= R\rho(2:M);  <span class="comment">% inv(R) * rho(2:M)</span>
    coeficientes(:,x) = B;

    <span class="comment">% FFT</span>
    G = sqrt( rho(1) -  B' * rho(2:end));
    fft_S_estimado_actual = abs(freqz(G,[1;-B], ancho, <span class="string">'whole'</span>));
    fft_S_estimado(:,x) = fft_S_estimado_actual(1:ancho/2);

<span class="keyword">end</span>
</pre><h2 id="8">Envolventes de las vocales</h2><p>Se graficara la envolvente de cada vocal del audio. Se observa que las vocales <tt>a</tt> contienen su primer formante alrededor de los 750Hz y la <tt>i</tt> alrededor de los 350 Hz.</p><pre class="codeinput">subindices = [72 90 124 135];
f = 0:Fs/ancho:Fs - Fs/ancho;

figure
<span class="keyword">for</span> x = subindices
    plot(f(1:ancho/2),fft_S_estimado(:,x))
    hold <span class="string">on</span>
<span class="keyword">end</span>
legend(<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'i'</span>,<span class="string">'a'</span>)
xlabel(<span class="string">'Frecuencia [Hz]'</span>)
ylabel(<span class="string">'Amplitud'</span>)
xlim([0 4e3])
</pre><img vspace="5" hspace="5" src="Practica4_04.png" style="width:560px;height:420px;" alt=""> <h2 id="9">Comparaci&oacute;n de la superficie obtenida con el espectrograma</h2><p>Se grafica el espectrograma del audio junto al gr&aacute;fico de la superficie obtenida. Como es de esperarse, la superficie obtenida esta compuesta por curvas mas suaves que las obtenidas mediante DFT.</p><pre class="codeinput">Noverlap = Fs*(ventana-paso)/2;

figure
spectrogram(audio, hanning(ancho) ,Noverlap, length(audio), Fs, <span class="string">'yaxis'</span>)
colormap <span class="string">winter</span>
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Frecuencia [kHz]'</span>)

t = (inicios-1)/Fs;

figure
surf(t,f(1:ancho/2)/1e3,log10(fft_S_estimado))
colormap <span class="string">winter</span>
shading <span class="string">interp</span>
set(gca,<span class="string">'xlim'</span>,[0 t(end)+paso], <span class="string">'ylim'</span>, [0 Fs/2e3]);
view(2)
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Frecuencia [kHz]'</span>)
</pre><img vspace="5" hspace="5" src="Practica4_05.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="Practica4_06.png" style="width:560px;height:420px;" alt=""> <h2 id="10">LPC aplicado a codificaci&oacute;n</h2><p>Se realizar&aacute;n simulaciones de la aplicacion de LPC para codificaci&oacute;n. Hasta ahora se ha dividido la informaci&oacute;n de la se&ntilde;al en los coeficientes que dan informaci&oacute;n del espectro de la se&ntilde;al y la informaci&oacute;n del error de predicci&oacute;n. A partir del error y los coeficientes se construir&aacute; la se&ntilde;al original.</p><h2 id="11">Obtenci&oacute;n del error y sintetizado de la se&ntilde;al</h2><p>Mediante la funci&oacute;n <tt>filter</tt> se obtiene el error de cada segmento de la se&ntilde;al. Se aplicar&aacute; solo a porciones de audio de 10mseg, ya que al filtrar 25mseg pero luego tomar solo 10mseg de error, el error es mayor. Luego se utiliza la funci&oacute;n <tt>sintetizar</tt> que reconstruye el audio en base al error y los coeficientes. Se observa que el audio original y el sintetizado son exactamente iguales, a excepcion de los primeros subindices por las condiciones iniciales nulas utilizadas. Finalmente se grafica un zoom de la se&ntilde;al para que se pueda apreciar que las se&ntilde;ales son exactamente iguales.</p><pre class="codeinput">zf = zeros(M-1,1); <span class="comment">% condiciones iniciales</span>
error = [];
<span class="keyword">for</span> x = 1:length(inicios)

    S = audio(inicios(x):inicios(x)+paso*Fs-1);
    [error_actual, zf] = filter([-1;coeficientes(:,x)], 1, S, zf);
    error = [error error_actual'];

<span class="keyword">end</span>

S_recibida = sintetizar(error, coeficientes, Fs*paso, zf);
t_audio_sintetizado = 0:1/Fs:length(S_recibida)/Fs - 1/Fs;

figure
plot(t_audio_sintetizado, S_recibida)
hold <span class="string">on</span>
plot(t_audio_sintetizado, audio(1:length(t_audio_sintetizado)))
legend(<span class="string">'audio recibido'</span>,<span class="string">'audio original'</span>)
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Amplitud'</span>)

figure
plot(t_audio_sintetizado, S_recibida)
hold <span class="string">on</span>
plot(t_audio_sintetizado, audio(1:length(t_audio_sintetizado)))
legend(<span class="string">'audio recibido'</span>,<span class="string">'audio original'</span>)
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Amplitud'</span>)
xlim([1.35 1.4])
</pre><img vspace="5" hspace="5" src="Practica4_07.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="Practica4_08.png" style="width:560px;height:420px;" alt=""> <h2 id="12">Errores redondeados</h2><p>A continuaci&oacute;n se redondear&aacute; a punto fijo de 8, 6 y 4 bits y se sintetizar&aacute; nuevamente la se&ntilde;al. Para esto se utilizar&aacute;n las funciones implementadas <tt>redondear</tt> y <tt>sintetizar</tt>. Finalmente se graficar&aacute;n las se&ntilde;ales sintetizadas y se reproducira un audio para comparar dichas se&ntilde;ales. En el audio se reproducir&aacute; primero el audio original, luego el audio sintetizado sin redondear y finalmente los audios sintetizados de 8, 6 y 4 bits. Ver la funci&oacute;n <a href="sintetizar.html">sintetizar</a> y  <a href="redondear.html">redondear</a> para mas detalles sobre su implementacion.</p><pre class="codeinput"><span class="comment">% Redondeando a punto fijo de 8bit</span>
error_8bit = redondear(error, 8);
S_recibida_8bit = sintetizar(error_8bit, coeficientes, Fs*paso, zf);

<span class="comment">% Redondeando a punto fijo de 6bit</span>
error_6bit = redondear(error, 6);
S_recibida_6bit = sintetizar(error_6bit, coeficientes, Fs*paso, zf);


<span class="comment">% Redondeando a punto fijo de 4bit</span>
error_4bit = redondear(error, 4);
S_recibida_4bit = sintetizar(error_4bit, coeficientes, Fs*paso, zf);
t_error = 0:1/Fs:(length(error)-1)/Fs;

<span class="comment">% Reproduzco los audios</span>
sound([audio' S_recibida S_recibida_8bit S_recibida_6bit S_recibida_4bit], Fs);

t_salida = 0:1/Fs:(length(S_recibida)-1)/Fs;

bits_totales_16bit = length(error) * 16;
bits_ahorrados_8bit = bits_totales_16bit - length(error_8bit)*8;
bits_ahorrados_6bit = bits_totales_16bit - length(error_6bit)*6;
bits_ahorrados_4bit = bits_totales_16bit - length(error_4bit)*4;

<span class="comment">% Los paso a Kbits;</span>
bits_ahorrados_8bit = bits_ahorrados_8bit * 1e-3;
bits_ahorrados_6bit = bits_ahorrados_6bit * 1e-3;
bits_ahorrados_4bit = bits_ahorrados_4bit * 1e-3;


disp([<span class="string">'Bits ahorrados utilizando 8 bits = '</span> num2str(bits_ahorrados_8bit) <span class="string">' kbit'</span>]);
disp([<span class="string">'Bits ahorrados utilizando 6 bits = '</span> num2str(bits_ahorrados_6bit) <span class="string">' kbit'</span>]);
disp([<span class="string">'Bits ahorrados utilizando 4 bits = '</span> num2str(bits_ahorrados_4bit) <span class="string">' kbit'</span>]);
</pre><pre class="codeoutput">Bits ahorrados utilizando 8 bits = 343.04 kbit
Bits ahorrados utilizando 6 bits = 428.8 kbit
Bits ahorrados utilizando 4 bits = 514.56 kbit
</pre><h2 id="13">Grafico de los errores y las se&ntilde;ales sintetizadas</h2><p>A continuacion se grafican los errores con distintos redondeos para poder compararlos con el original. Se grafica el error total y en una porcion de la se&ntilde;al para tener una mejor visualizaci&oacute;n. Luego se realiza lo mismo pero con las se&ntilde;ales sintetizadas.</p><h2 id="14">Errores</h2><pre class="codeinput">figure
plot(t_error,error)
hold <span class="string">on</span>
plot(t_error,error_8bit)
hold <span class="string">on</span>
plot(t_error,error_6bit)
hold <span class="string">on</span>
plot(t_error,error_4bit)
legend(<span class="string">'error original'</span>, <span class="string">'error 8bit'</span>, <span class="string">'error 6bit'</span>, <span class="string">'error 4bit'</span>);
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Amplitud'</span>)

figure
plot(t_error,error)
hold <span class="string">on</span>
plot(t_error,error_8bit)
hold <span class="string">on</span>
plot(t_error,error_6bit)
hold <span class="string">on</span>
plot(t_error,error_4bit)
legend(<span class="string">'error original'</span>, <span class="string">'error 8bit'</span>, <span class="string">'error 6bit'</span>, <span class="string">'error 4bit'</span>);
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Amplitud'</span>)
xlim([1.35 1.36])
</pre><img vspace="5" hspace="5" src="Practica4_09.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="Practica4_10.png" style="width:560px;height:420px;" alt=""> <h2 id="15">Se&ntilde;ales sintetizadas</h2><pre class="codeinput">figure
plot(t_salida, S_recibida)
hold <span class="string">on</span>
plot(t_salida,S_recibida_8bit)
hold <span class="string">on</span>
plot(t_salida,S_recibida_6bit)
hold <span class="string">on</span>
plot(t_salida,S_recibida_4bit)
legend(<span class="string">'sintetizado double'</span>, <span class="string">'sintetizado 8bit'</span>, <span class="string">'sintetizado 6bit'</span>, <span class="string">'sintetizado 4bit'</span>);
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Amplitud'</span>)

figure
plot(t_salida, S_recibida)
hold <span class="string">on</span>
plot(t_salida,S_recibida_8bit)
hold <span class="string">on</span>
plot(t_salida,S_recibida_6bit)
hold <span class="string">on</span>
plot(t_salida,S_recibida_4bit)
legend(<span class="string">'sintetizado double'</span>, <span class="string">'sintetizado 8bit'</span>, <span class="string">'sintetizado 6bit'</span>, <span class="string">'sintetizado 4bit'</span>);
xlabel(<span class="string">'Tiempo [seg]'</span>)
ylabel(<span class="string">'Amplitud'</span>)
xlim([1.35 1.36])
</pre><img vspace="5" hspace="5" src="Practica4_11.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="Practica4_12.png" style="width:560px;height:420px;" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Práctica 4: Linear Predictive Coding(LPC)
% Vázquez Matías - 
% Padron:91523 - 
% |mfvazquezfiuba@gmail.com|

%% LPC y la envolvente del espectro: chequeo
% Se realizará un chequeo aplicando LPC a una sección específica
% de ancho temporal fijo sobre una señal, para observar la envolvente
% del espectro. 

%% Constantes utilizadas
% 
% * |ventana|: el ancho de la ventana utiliaza, en mseg.
% * |ancho|: es la cantidad de elementos del audio que componen 25 mseg de audio.
% * |inicio|: subindice a partir del cual se aplica la ventana. 
% * |M|: numero de coeficientes utilizados
% * |t|: eje X de los gráficos en función del tiempo.
% * |f|: eje X de los gráficos en función de la frecuencia.

close all
clear

[audio, Fs] = audioread('fantasia.wav');

ventana = 25e-3;
ancho =  ventana  * Fs;

inicio = 14000;
M = 20;
S = audio(inicio:inicio+ancho-1);

t = 0:1/Fs:ventana-1/Fs;
t = t*1e3; % Paso el tiempo a mseg.
f = 0:Fs/ancho:Fs - Fs/ancho;


%% Comparación de la señal temporal y la predicha
% Mediante la autocorrelación del fragmento de audio, se obtienen los
% coeficientes rho, y luego con estos se obtienen los coeficientes LPC.
% Con estos coeficientes se obtiene la señal de audio predicha utilizando
% la función |filter|.
% Luego restando la señal temporal y la predicha se obtiene el error.
% Se observa que tiene picos espaciados aproximadamente en 5 mseg.
% Y que tiene una amplitud máxima de alrededor 0.07, exceptuando los
% primeros subindices del error ya que la señal temporal es un audio
% empezado, y la predicha se obtiene utilizando condiciones iniciales nulas.

autocorrelacion = xcorr(S);
rho = autocorrelacion(ancho:ancho+M-1);   % rho = [rho(0) rho(1) ... rho(M)]

subindices = toeplitz(1:M-1);
R = rho(subindices);

B= R\rho(2:M);  % inv(R) * rho(2:M)

S_estimado = filter([0; B],1 ,S); % Filter es un filtro causal

figure
plot(t, S,'b')
hold on
plot(t, S_estimado,'r');
xlabel('tiempo [ms]')
ylabel('Amplitud')
legend('señal original','señal predicha')

error = S_estimado-S;
figure
plot(t,error);
legend('error')
xlabel('tiempo [ms]')
ylabel('Amplitud')


%% Envolvente de la señal temporal y la predicha
% Se muestra un gráfico de la envolvente del espectro del audio ventaneado.
% Para la señal temporal se usa la función |fft| mientras que para la
% predicha se usa la función |freqz| que devuelve la respuesta en
% frecuencia del filtro.
% Se verifica que el primer pico se encuentra en los 720Hz, por lo que
% esta sección de audio se trataría de la vocal |a|. 

G = sqrt( rho(1) -  B' * rho(2:end));

fft_S = abs(fft(S));
fft_S_estimado = abs(freqz(G,[1;-B], ancho, 'whole'));

figure
plot(f(1:ancho/2),fft_S(1:ancho/2),'b')
hold on
plot(f(1:ancho/2),fft_S_estimado(1:ancho/2),'r');
legend('FFT(S)', 'FFT(S estimada)')
xlabel('Frecuencia [Hz]')
ylabel('Amplitud')

%% LPC y la envolvente del espectro: Análisis en todo el audio
% Se realizará el mismo análisis que en el intervalo de 25mseg anterior
% pero a todo el audio. Se recorrerá el audio cada 10mseg aplicando
% ventanas de 25mseg para obtener la envolvente del espectro en cada
% sección, de forma de obtener una superficie que será semejante a un
% espectrograma.

%% Constantes utilizadas
% 
% * |paso|: intervalo en tiempo que hay entre cada sección de audio tomada.
% * |inicios|: vector con la posición del audio donde se inicia el
% analisis.

clearvars -except audio Fs M ventana ancho

paso = 10e-3;
inicios = 1:paso*Fs:length(audio)-ancho;

%% Calculo anterior sobre toda la señal

for x = 1:length(inicios)

    S = audio(inicios(x):inicios(x)+ancho-1);

    % S_estimado
    autocorrelacion = xcorr(S);
    rho = autocorrelacion(ancho:ancho+M-1);   % rho = [rho(0) rho(1) ... rho(M)]

    subindices = toeplitz(1:M-1);
    R = rho(subindices);
    B= R\rho(2:M);  % inv(R) * rho(2:M)
    coeficientes(:,x) = B;
        
    % FFT
    G = sqrt( rho(1) -  B' * rho(2:end));
    fft_S_estimado_actual = abs(freqz(G,[1;-B], ancho, 'whole'));
    fft_S_estimado(:,x) = fft_S_estimado_actual(1:ancho/2);
        
end

%% Envolventes de las vocales
% Se graficara la envolvente de cada vocal del audio. Se observa que las
% vocales |a| contienen su primer formante alrededor de los 750Hz y la |i|
% alrededor de los 350 Hz.

subindices = [72 90 124 135];
f = 0:Fs/ancho:Fs - Fs/ancho;

figure
for x = subindices
    plot(f(1:ancho/2),fft_S_estimado(:,x))
    hold on
end
legend('a','a','i','a')
xlabel('Frecuencia [Hz]')
ylabel('Amplitud')
xlim([0 4e3])


%% Comparación de la superficie obtenida con el espectrograma
% Se grafica el espectrograma del audio junto al gráfico de la superficie
% obtenida. Como es de esperarse, la superficie obtenida esta compuesta por
% curvas mas suaves que las obtenidas mediante DFT. 

Noverlap = Fs*(ventana-paso)/2;

figure
spectrogram(audio, hanning(ancho) ,Noverlap, length(audio), Fs, 'yaxis')
colormap winter
xlabel('Tiempo [seg]')
ylabel('Frecuencia [kHz]')

t = (inicios-1)/Fs;

figure
surf(t,f(1:ancho/2)/1e3,log10(fft_S_estimado))
colormap winter
shading interp
set(gca,'xlim',[0 t(end)+paso], 'ylim', [0 Fs/2e3]);
view(2)
xlabel('Tiempo [seg]')
ylabel('Frecuencia [kHz]')

%% LPC aplicado a codificación
% Se realizarán simulaciones de la aplicacion de LPC para codificación. 
% Hasta ahora se ha dividido la información de la señal en los coeficientes 
% que dan información del espectro de la señal y la información del error de
% predicción. A partir del error y los coeficientes se construirá la señal 
% original.

%% Obtención del error y sintetizado de la señal
% Mediante la función |filter| se obtiene el error de cada segmento de la
% señal. Se aplicará solo a porciones de audio de 10mseg, ya que al
% filtrar 25mseg pero luego tomar solo 10mseg de error, el error es
% mayor. Luego se utiliza la función |sintetizar| que reconstruye el audio
% en base al error y los coeficientes. Se observa que el audio original y
% el sintetizado son exactamente iguales, a excepcion de los primeros
% subindices por las condiciones iniciales nulas utilizadas.
% Finalmente se grafica un zoom de la señal para que se pueda apreciar que 
% las señales son exactamente iguales.

zf = zeros(M-1,1); % condiciones iniciales
error = [];
for x = 1:length(inicios)

    S = audio(inicios(x):inicios(x)+paso*Fs-1);
    [error_actual, zf] = filter([-1;coeficientes(:,x)], 1, S, zf);
    error = [error error_actual'];
    
end

S_recibida = sintetizar(error, coeficientes, Fs*paso, zf);
t_audio_sintetizado = 0:1/Fs:length(S_recibida)/Fs - 1/Fs;

figure
plot(t_audio_sintetizado, S_recibida)
hold on
plot(t_audio_sintetizado, audio(1:length(t_audio_sintetizado)))
legend('audio recibido','audio original')
xlabel('Tiempo [seg]')
ylabel('Amplitud')

figure
plot(t_audio_sintetizado, S_recibida)
hold on
plot(t_audio_sintetizado, audio(1:length(t_audio_sintetizado)))
legend('audio recibido','audio original')
xlabel('Tiempo [seg]')
ylabel('Amplitud')
xlim([1.35 1.4])

%% Errores redondeados
% A continuación se redondeará a punto fijo de 8, 6 y 4 bits y se
% sintetizará nuevamente la señal. Para esto se utilizarán las funciones
% implementadas |redondear| y |sintetizar|.
% Finalmente se graficarán las señales
% sintetizadas y se reproducira un audio para comparar dichas señales. En
% el audio se reproducirá primero el audio original, luego el audio
% sintetizado sin redondear y finalmente los audios sintetizados de 8, 6 y
% 4 bits.
% Ver la función <sintetizar.html sintetizar> y  <redondear.html redondear>
% para mas detalles sobre su implementacion.

% Redondeando a punto fijo de 8bit
error_8bit = redondear(error, 8);
S_recibida_8bit = sintetizar(error_8bit, coeficientes, Fs*paso, zf);

% Redondeando a punto fijo de 6bit
error_6bit = redondear(error, 6);
S_recibida_6bit = sintetizar(error_6bit, coeficientes, Fs*paso, zf);


% Redondeando a punto fijo de 4bit
error_4bit = redondear(error, 4);
S_recibida_4bit = sintetizar(error_4bit, coeficientes, Fs*paso, zf);
t_error = 0:1/Fs:(length(error)-1)/Fs;

% Reproduzco los audios
sound([audio' S_recibida S_recibida_8bit S_recibida_6bit S_recibida_4bit], Fs);

t_salida = 0:1/Fs:(length(S_recibida)-1)/Fs;

bits_totales_16bit = length(error) * 16;
bits_ahorrados_8bit = bits_totales_16bit - length(error_8bit)*8;
bits_ahorrados_6bit = bits_totales_16bit - length(error_6bit)*6;
bits_ahorrados_4bit = bits_totales_16bit - length(error_4bit)*4;

% Los paso a Kbits;
bits_ahorrados_8bit = bits_ahorrados_8bit * 1e-3;
bits_ahorrados_6bit = bits_ahorrados_6bit * 1e-3;
bits_ahorrados_4bit = bits_ahorrados_4bit * 1e-3;


disp(['Bits ahorrados utilizando 8 bits = ' num2str(bits_ahorrados_8bit) ' kbit']);
disp(['Bits ahorrados utilizando 6 bits = ' num2str(bits_ahorrados_6bit) ' kbit']);
disp(['Bits ahorrados utilizando 4 bits = ' num2str(bits_ahorrados_4bit) ' kbit']);


%% Grafico de los errores y las señales sintetizadas
% A continuacion se grafican los errores con distintos redondeos para poder
% compararlos con el original. Se grafica el error total y en una porcion
% de la señal para tener una mejor visualización. Luego se realiza lo mismo
% pero con las señales sintetizadas.

%% Errores

figure
plot(t_error,error)
hold on
plot(t_error,error_8bit)
hold on
plot(t_error,error_6bit)
hold on
plot(t_error,error_4bit)
legend('error original', 'error 8bit', 'error 6bit', 'error 4bit');
xlabel('Tiempo [seg]')
ylabel('Amplitud')

figure
plot(t_error,error)
hold on
plot(t_error,error_8bit)
hold on
plot(t_error,error_6bit)
hold on
plot(t_error,error_4bit)
legend('error original', 'error 8bit', 'error 6bit', 'error 4bit');
xlabel('Tiempo [seg]')
ylabel('Amplitud')
xlim([1.35 1.36])

%% Señales sintetizadas

figure
plot(t_salida, S_recibida)
hold on
plot(t_salida,S_recibida_8bit)
hold on
plot(t_salida,S_recibida_6bit)
hold on
plot(t_salida,S_recibida_4bit)
legend('sintetizado double', 'sintetizado 8bit', 'sintetizado 6bit', 'sintetizado 4bit');
xlabel('Tiempo [seg]')
ylabel('Amplitud')

figure
plot(t_salida, S_recibida)
hold on
plot(t_salida,S_recibida_8bit)
hold on
plot(t_salida,S_recibida_6bit)
hold on
plot(t_salida,S_recibida_4bit)
legend('sintetizado double', 'sintetizado 8bit', 'sintetizado 6bit', 'sintetizado 4bit');
xlabel('Tiempo [seg]')
ylabel('Amplitud')
xlim([1.35 1.36])

##### SOURCE END #####
--></body></html>